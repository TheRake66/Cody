<?php
namespace Kernel\Security\Vulnerability;

use Kernel\Debug\Log;
use Kernel\Html\Builder;
use Kernel\Io\Convert\Encoded;



/**
 * Librairie  de gestion de la vulnérabilité CSRF (Cross-Site Request Forgery).
 *
 * @author Thibault Bustos (TheRake66)
 * @version 1.0
 * @package Kernel\Security\Vulnerability
 * @category Framework source
 * @license MIT License
 * @copyright © 2022 - Thibault BUSTOS (TheRake66)
 */
abstract class Csrf {

	/**
	 * Génère un jeton aléatoire d'une taille spécifiée cryptographiquement sécurisée.
	 * 
	 * @param int $size La taille du jeton.
	 * @return string Le jeton généré.
	 */
	static function generate($size = 32) {
		if (function_exists('random_bytes')) {
			return bin2hex(random_bytes($size));
		} elseif (function_exists('openssl_random_pseudo_bytes')) {
			return bin2hex(openssl_random_pseudo_bytes($size));
		} else {
			Log::add('Attention, impossible de générer le jeton de manière sécurisée. Veuillez activer l\'extention "openssl" ou utiliser PHP 7.0+.', Log::LEVEL_WARNING);
			return Encoded::random($size);
		}
	}


	/**
	 * Initialise un champ caché avec un jeton.
	 * 
	 * @return string Le code HTML du champ caché.
	 */
    static function init() {
		if (!isset($_SESSION['csrf_token'])) {
			$token = self::generate();
			Log::add('Génération d\'un jeton CSRF : "' . $token . '".');
			$_SESSION['csrf_token'] = $token;
		} else {
			$token = $_SESSION['csrf_token'];
		}
		return Builder::create('input', [
			'type' => 'hidden',
			'name' => 'csrf_token',
			'value' => $token  
        ]);
    }


	/**
	 * Vérifie si le jeton CSRF est valide.
	 * 
	 * @return bool True si le jeton est valide, false sinon.
	 */
	static function check() {
		if (isset($_SESSION['csrf_token']) && isset($_POST['csrf_token']) &&
			$_SESSION['csrf_token'] === $_POST['csrf_token']) {
			Log::add('Le jeton CSRF est valide.', Log::LEVEL_GOOD);
			return true;
		} else {
			Log::add('Le jeton CSRF est invalide.', Log::LEVEL_WARNING);
			http_response_code(405);
			return false;
		}
	}

	
	/**
	 * Détruit le jeton CSRF.
	 * 
	 * @return void
	 */
	static function destroy() {
		unset($_SESSION['csrf_token']);
		unset($_POST['csrf_token']);
	}

}

?>